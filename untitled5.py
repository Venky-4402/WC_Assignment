# -*- coding: utf-8 -*-
"""Untitled5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ku7shxS_faV4AefZsEt-OA6Utv4ZzTV_
"""



import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt

# Use previously calculated results
# Load the required datasets and precomputed data
@st.cache
def load_data():
    # Mocking data loading - replace this with actual cleaned datasets
    top_20_with_cap = pd.read_csv('top_20_with_cap.csv')  # Replace with the file containing top 20 stock data
    portfolio_value_monthly = pd.read_csv('portfolio_value_monthly.csv', index_col=0, parse_dates=True)
    portfolio_value_quarterly = pd.read_csv('portfolio_value_quarterly.csv', index_col=0, parse_dates=True)
    portfolio_value_annually = pd.read_csv('portfolio_value_annually.csv', index_col=0, parse_dates=True)
    benchmark_prices = pd.read_csv('benchmark_prices.csv', index_col=0, parse_dates=True)

    return top_20_with_cap, portfolio_value_monthly, portfolio_value_quarterly, portfolio_value_annually, benchmark_prices

# Load data
top_20_with_cap, portfolio_value_monthly, portfolio_value_quarterly, portfolio_value_annually, benchmark_prices = load_data()

# App Title
st.title("Quantitative Investment Strategy: Portfolio Backtesting")

# Portfolio Overview
st.header("Portfolio Overview")
st.write("This portfolio was constructed using a market cap-weighted strategy with the following stocks:")
st.dataframe(top_20_with_cap[['Instrument', 'Company Market Cap', 'Weight']])

# Performance Visualizations
st.header("Portfolio vs Benchmark Performance")
st.write("Compare the performance of the portfolio against the benchmark.")

# Normalize values
portfolio_monthly_norm = (portfolio_value_monthly / portfolio_value_monthly.iloc[0]) * 100
portfolio_quarterly_norm = (portfolio_value_quarterly / portfolio_value_quarterly.iloc[0]) * 100
portfolio_annually_norm = (portfolio_value_annually / portfolio_value_annually.iloc[0]) * 100
benchmark_norm = (benchmark_prices / benchmark_prices.iloc[0]) * 100

# Plot Portfolio vs Benchmark
fig, ax = plt.subplots(figsize=(10, 6))
ax.plot(portfolio_monthly_norm, label="Portfolio (Monthly Rebalancing)", color="blue", linewidth=2)
ax.plot(portfolio_quarterly_norm, label="Portfolio (Quarterly Rebalancing)", color="orange", linestyle="--", linewidth=2)
ax.plot(portfolio_annually_norm, label="Portfolio (Annual Rebalancing)", color="green", linestyle="-.", linewidth=2)
ax.plot(benchmark_norm, label="Benchmark", color="red", linestyle=":", linewidth=2)
ax.set_title("Portfolio vs Benchmark Performance")
ax.set_xlabel("Date")
ax.set_ylabel("Normalized Value")
ax.legend()
st.pyplot(fig)

# Rebalancing Comparison
st.header("Rebalancing Frequency Comparison")
st.write("Analyze how rebalancing frequency impacts portfolio performance.")

# Performance Metrics
metrics = {
    "Monthly": {"CAGR": 0.220698, "Max Drawdown": -0.224751, "Volatility": 1.363143},
    "Quarterly": {"CAGR": 0.217901, "Max Drawdown": -0.213566, "Volatility": 2.476906},
    "Annually": {"CAGR": 0.221486, "Max Drawdown": -0.100603, "Volatility": 3.294259},
}

metrics_df = pd.DataFrame(metrics).T
metrics_df.columns = ["CAGR", "Maximum Drawdown", "Annualized Volatility"]

# Display Metrics Table
st.write("Performance Metrics by Rebalancing Frequency:")
st.dataframe(metrics_df.style.format({"CAGR": "{:.2%}", "Maximum Drawdown": "{:.2%}", "Annualized Volatility": "{:.2%}"}))

# Interactive Frequency Selection
st.header("Interactive Rebalancing Selection")
frequency = st.selectbox("Choose Rebalancing Frequency:", ["Monthly", "Quarterly", "Annually"])
if frequency == "Monthly":
    st.line_chart(portfolio_monthly_norm)
elif frequency == "Quarterly":
    st.line_chart(portfolio_quarterly_norm)
else:
    st.line_chart(portfolio_annually_norm)

# Summary
st.header("Key Insights")
st.write("""
- **Annual Rebalancing**: Highest CAGR (22.15%) and lowest drawdown (-10.06%), but highest volatility.
- **Monthly Rebalancing**: Balanced volatility and drawdown, suitable for stability.
- **Quarterly Rebalancing**: Intermediate performance, but no standout advantage.
""")

st.write("This app dynamically visualizes the portfolio's performance, providing a comprehensive comparison of rebalancing strategies.")

